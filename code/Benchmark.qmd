---
title: "Benchmark"
author: "Leoni Zimmermann"
html:
  code-fold: true
  code-summary: "Show the code"
editor: visual
---

# Prep

## Libraries

```{r message=FALSE, warning=FALSE}
#---------------------------Seed------------------------------------------------
set.seed(42)
#---------------------------Libraries-------------------------------------------
library(MOFA2)
library(scater)
library(scran)
library(StabMap)
library(tidyverse)
library(cluster)
library(patchwork)
library(fpc)
library(MultiAssayExperiment)
library(plotly)
```

## Preparing Data

Load Data

```{r}
#---------------------------Dataset---------------------------------------------
# Peripheral Blood Mononuclear Cells provided by 10x Genomics website
# 10x Genomics Multiome technology enables simultaneous profiling of the transcriptome 
# (using 3’ gene expression) and epigenome (using ATAC-seq) from single cells to deepen 
# our understanding of how genes are expressed and regulated across different cell types.

# mae <- scMultiome("pbmc_10x", mode = "*", dry.run = FALSE, format = "MTX")

# Loaded from RDS cause I cant install the SingleCellMultiModal package
mae <- readRDS("~/R/Data/data.RDS")
metadata <- mae@colData
```

Normalization

```{r}
#---------------------------Data preperation------------------------------------
# Normalization RNA
sce.rna <- experiments(mae)[["rna"]]
sce.rna <- logNormCounts(sce.rna)

# Feature selection
decomp <- modelGeneVar(sce.rna)
hvgs <- rownames(decomp)[decomp$mean>0.01 & decomp$p.value <= 0.05]

sce.rna <- sce.rna[hvgs,]


# Normalization ATAC
sce.atac <- experiments(mae)[["atac"]]
sce.atac <- logNormCounts(sce.atac)

# Feature selection using highly variable peaks
decomp <- modelGeneVar(sce.atac)
hvgs <- rownames(decomp)[decomp$mean>0.25
                         & decomp$p.value <= 0.05]

sce.atac <- sce.atac[hvgs,]

logcounts_all <- rbind(logcounts(sce.rna), logcounts(sce.atac))
```

## Some general dataframes etc.

```{r}
# Celltypes of all samples
all_celltypes <- as.data.frame(setNames(metadata$celltype, colnames(logcounts_all))) %>%
                    rename(celltype = "setNames(metadata$celltype, colnames(logcounts_all))")

# Clusters
cluster <- as.data.frame(metadata) %>% group_by(celltype) %>% summarise(n = n()) %>% mutate(k = 1:14) %>% select(-n)
```

## StabMap

```{r}
#---------------------------StabMap---------------------------------------------

# Seperation ATAC Multiome
names <- c(rep("ATAC", ncol(logcounts_all)/2), rep("Multiome", ncol(logcounts_all)/2))

# Assay Types
assayType = ifelse(rownames(logcounts_all) %in% rownames(sce.rna),
                   "rna", "atac")

# List for StabMap
assay_list = list(
  ATAC = logcounts_all[assayType %in% c("rna"), names %in% c("ATAC")], # 952x5016 -> only RNA in first half of cells
  Multiome = logcounts_all[assayType %in% c("rna", "atac"), names %in% c("Multiome")] #1740x5016 -> ATAC and RNA, second half of cells
)


# StabMap
mosaicDataUpSet(assay_list)
plot(mosaicDataTopology(assay_list))

stab = stabMap(assay_list,
               reference_list = c("Multiome"),
               plot = FALSE,
               maxFeatures = 1100)

# UMAP
stab_umap_coord <- as.data.frame(calculateUMAP(t(stab)))


# Add metadata to the UMAP results (celltype, if it was an NA cell, cluster)
stab_umap <- merge( as.data.frame(metadata), stab_umap_coord, by =0 ) %>% 
                mutate(isNA = ifelse(Row.names %in% colnames(assay_list$ATAC), 1, 0)) %>% # 1 is TRUE, 0 is FALSE
                full_join(cluster) %>%
                column_to_rownames("Row.names")

```

## MOFA model

```{r}
#---------------------------MOFA------------------------------------------------

# Put NAs in data, takes a long time
# logcounts_allNA <- logcounts_all
# logcounts_allNA[953:1740, 1:ncol(logcounts_all)/2] <- NA

logcounts_allNA <- readRDS("~/R/Data/logcountsNA.RDS")

# Create list for MOFA
mofa_list <- list(
  RNA =  logcounts_allNA[1:952,],
  ATAC = logcounts_allNA[953: 1740,]
)

# MOFA model and training
model <- create_mofa(mofa_list)
samples_metadata(model) <- as.data.frame(metadata) %>% 
                              rownames_to_column("sample") %>% 
                              mutate(isNA =  c(rep(1, ncol(logcounts_all)/2), rep(0, ncol(logcounts_all) - ncol(logcounts_all)/2))) # 1 is TRUE, 0 is FALSE
plot_data_overview(model)


model_opts <- get_default_model_options(model)
model_opts$num_factors <- 15
model_opts$spikeslab_weights <- TRUE
MOFAobject <- prepare_mofa(model,
                           model_options = model_opts)

  # set.seed(42)
  # run_mofa(MOFAobject, outfile = "R/Data/model.hdf5", use_basilisk = TRUE)

trained_model <- load_model("~/R/Data/model.hdf5")

# UMAP
trained_model <- run_umap(trained_model)
mofa_umap_coord <- trained_model@dim_red$UMAP %>% select(UMAP1, UMAP2)

# Add metadata to the UMAP results (celltype, if it was an NA cell, cluster)
mofa_umap <- merge(trained_model@dim_red$UMAP, all_celltypes, by = 0)  %>%
                full_join(cluster) %>% 
                mutate(isNA =  c(rep(1, ncol(logcounts_all)/2), rep(0, ncol(logcounts_all) - ncol(logcounts_all)/2))) %>%  # 1 is TRUE, 0 is FALSE
                column_to_rownames("Row.names") %>%
                select(-sample)
```

```{r}
# Test that same cells are NA
# sum(colnames(mofa_list$ATAC) %in% colnames(assay_list$ATAC))
```

# Dimension reduction

## Comparison UMAPS

```{r}
# MOFA
UM1 <- plot_dimred(trained_model, method = "UMAP", color_by = "celltype", dot_size =1) + ggtitle("MOFA celltype")
UM2 <- plot_dimred(trained_model, method = "UMAP", color_by = "isNA", dot_size =1)+ ggtitle("MOFA NA")
UM3 <- plot_dimred(trained_model, method = "UMAP", color_by = "broad_celltype", dot_size =1)+ ggtitle("MOFA broad celltype")

# StabMap
US1 <- ggplot(stab_umap) +
  geom_point(aes(x = V1, y = V2, color = celltype), size = .1) +
  theme_light() +
  ggtitle("StabMap celltype")
US2 <- ggplot(stab_umap) +
  geom_point(aes(x = V1, y = V2, color = isNA), size = .1) +
  theme_light() +
  ggtitle("StabMap NA")
US3 <- ggplot(stab_umap) +
  geom_point(aes(x = V1, y = V2, color = broad_celltype), size = .1) +
  theme_light() +
  ggtitle("StabMap broad celltype")

# Plot
combined_plot <- (UM1 + UM2 + UM3) / (US1 + US2 + US3) + plot_annotation(title = 'Comparison UMAP')
print(combined_plot)

# Interactive plots
# ggplotly(UM1)
```

Nach Zelltyp: Mittelmäßig aufgetrennt

Nach groben Zelltyp: Gut aufgetrennt

Nach NA: Gut verteilt/nicht aufgetrennt (so sollte es sein)

Myeloid cells:

Classical Monocytes --\> intermediate MC --\> non-classical MC

Monocytes and dendritic cells (DC) have common ancestor

Lymphoid cells:

naive and memory B cells together (good)

plasmacytoid DC have common ancestor with myeloid dc, their progenitor can also make plasmacytoid dc

```         
"CD56 (bright) NK cells"  "CD56 (dim) NK cells"     "MAIT T cells"  "effector CD8 T cells"  "memory CD4 T cells"  "naive CD4 T cells" naive CD8 T cells
```

## Silhouette

```{r}
#---------------------------Silhouette-------------------------------------------

#StabMap celltype

stab_sil <- silhouette(stab_umap$k, dist(stab_umap %>% select(V1, V2)))
stab_sil_sum <- stab_sil %>% 
  as.data.frame() %>% group_by(cluster) %>% summarise(score = mean(sil_width), 
                                                      frac_pos = sum(sil_width > 0)/n(),
                                                      pos_score = sum((sil_width>0)*sil_width)/sum(sil_width > 0)) #average quality of clustering for the well-clustered data points within each cluster
stab_sil_sum

#StabMap NA

stab_sil_NA <- silhouette(stab_umap$isNA, dist(stab_umap %>% select(V1, V2)))
stab_sil_sum_NA <- stab_sil_NA %>% 
  as.data.frame() %>% group_by(cluster) %>% summarise(score = mean(sil_width), 
                                                      frac_pos = sum(sil_width > 0)/n(),
                                                      pos_score = sum((sil_width>0)*sil_width)/sum(sil_width > 0))
stab_sil_sum_NA

#MOFA celltype

mofa_sil <- silhouette(mofa_umap$k, dist(mofa_umap %>% select(UMAP1, UMAP2)))
mofa_sil_sum <- mofa_sil %>% 
  as.data.frame() %>% group_by(cluster) %>% summarise(score = mean(sil_width), 
                                                      frac_pos = sum(sil_width > 0)/n(),
                                                      pos_score = sum((sil_width>0)*sil_width)/sum(sil_width > 0)) 
mofa_sil_sum

#MOFA NA 

mofa_sil_NA <- silhouette(mofa_umap$isNA, dist(mofa_umap %>% select(UMAP1, UMAP2)))
mofa_sil_sum_NA <- mofa_sil_NA %>% 
  as.data.frame() %>% group_by(cluster) %>% summarise(score = mean(sil_width), 
                                                      frac_pos = sum(sil_width > 0)/n(),
                                                      pos_score = sum((sil_width>0)*sil_width)/sum(sil_width > 0)) 
mofa_sil_sum_NA
```

Zelltypen: Cluster 5 (effector CD8 T cells) für beide Methoden schlecht --\> -0.4243316 (MOFA). Überschneidet sich mit Kluster 3 (MAIT T cells), Kluster 8 (memory CD4 T cells) und 2 (CD56 (dim) NK cells)

Plasmocytoid DC cells für beide Methoden am besten

Mean score für StabMap: 0.39, MOFA: 0.45

## More cluster stats

```{r}
stab_cluster_stats <- cluster.stats(dist(stab_umap %>% select(V1, V2)), stab_umap$k)
mofa_cluster_stats <- cluster.stats(dist(mofa_umap %>% select(UMAP1, UMAP2)), mofa_umap$k)
```

## Celltype accuracy (from StabMap paper)

Given a joint embedding, we perform a simulation such that discrete class labels corresponding to cell types are artificially removed (atac_query are the "removed" ones) for a subset of the data. We then perform k-nearest neighbors classification (k=5) to obtain the predicted class label for the artificially unlabeled data. The cell type classification accuracy is thus the proportion of cells for which the classification is correct compared to the true cell type label

Find the k-nearest neighbors in one data set for each point in another query data set, using exact or approximate algorithms

uniformed_fixed =\> One fixed k for all

The balanced eresult is first mean for celltype, then mean over all celltypes. Unbalanced one is just the mean over all cells

```{r}
source("adaptiveKNN.R")

# Predict "ATAC only" cell's cell types 
# Split Data
rna_train <- stab_umap$celltype[1:5016]
names(rna_train) <- rownames(stab_umap)[1:5016]
atac_query <- stab_umap$celltype[5016:10032]
names(atac_query) <- rownames(stab_umap)[5016:10032]

# StabMap
stab_knn_out = embeddingKNN(stab_umap_coord,
                       rna_train,
                       type = "uniform_fixed",
                       k_values = 5)
stab_knn_acc = mean(isEqual(stab_knn_out[names(atac_query),"predicted_labels"], atac_query), na.rm = TRUE)
stab_knn_acc_bal = mean(unlist(lapply(split(isEqual(stab_knn_out[names(atac_query),"predicted_labels"], atac_query), atac_query), mean, na.rm = TRUE)))

# MOFA
mofa_knn_out = embeddingKNN(mofa_umap_coord,
                       rna_train,
                       type = "uniform_fixed",
                       k_values = 5)
mofa_knn_acc = mean(isEqual(mofa_knn_out[names(atac_query),"predicted_labels"], atac_query), na.rm = TRUE)
mofa_knn_acc_bal = mean(unlist(lapply(split(isEqual(mofa_knn_out[names(atac_query),"predicted_labels"], atac_query), atac_query), mean, na.rm = TRUE)))

# Result
cat(" Accuracy StabMap: ", stab_knn_acc,"/",stab_knn_acc_bal,"(per celltype)", "\n","Accuracy MOFA: ", mofa_knn_acc,"/",mofa_knn_acc_bal,"(per celltype)")

```

Interpretation result

## Ideas

from WNN paper: get predicted expression of a gene (They used CD25 since it is hard to distinguish T cells in the dim reduction) from averaging the neighbors expression. THen calculate Correlation (Pearson and SPearman) to get quality

```{r}
# CD25
# plot_dimred(trained_model, method = "UMAP", color_by = "IL2RA", dot_size =1)+ ggtitle("MOFA CD25")

# CD57
# plot_dimred(trained_model, method = "UMAP", color_by = "", dot_size =1)+ ggtitle("MOFA CD57")

```

# Imputation

```{r}
#---------------------------Imputation------------------------------------------
imp = imputeEmbedding(
  assay_list,
  stab,
  reference = colnames(assay_list[["Multiome"]]),
  query = colnames(assay_list[["ATAC"]]))

trained_model <- impute(trained_model)
# imp$Multiome[953:963, 1:5]
# trained_model@imputed_data$ATAC[[1]][1:10, 1:5]

```

## RSME

```{r}
# StabMap
# Dataframe with predicted and real values

stab_imp_comp <- as.data.frame(as.matrix(imp$Multiome)[953:1740,]) %>%
                  rownames_to_column("feature") %>%
                  pivot_longer(-feature, names_to = "sample", values_to = "predicted") %>%
                  full_join(as.data.frame(as.matrix(logcounts_all[953:1740, 1:(ncol(logcounts_all)/2)])) %>%
                  rownames_to_column("feature") %>%
                  pivot_longer(-feature, names_to = "sample", values_to = "actual"))

stab_rsme <- sqrt(mean((stab_imp_comp$actual - stab_imp_comp$predicted)^2))
# MOFA
mofa_imp_comp <- as.data.frame(trained_model@imputed_data$ATAC[[1]][,1:(ncol(logcounts_all)/2)]) %>%
                  rownames_to_column("feature") %>%
                  pivot_longer(-feature, names_to = "sample", values_to = "predicted") %>%
                  full_join(as.data.frame(as.matrix(logcounts_all[953:1740, 1:(ncol(logcounts_all)/2)])) %>%
                  rownames_to_column("feature") %>%
                  pivot_longer(-feature, names_to = "sample", values_to = "actual"))

mofa_rsme <- sqrt(mean((mofa_imp_comp$actual - mofa_imp_comp$predicted)^2))

cat(" StabMap RSME:", stab_rsme, "\n", "MOFA RSME:",mofa_rsme )

```

## Comparison against baseline

```{r}
stab_baseline_comp <- as.data.frame(as.matrix(imp$Multiome)[953:1740,]) %>%
                        rownames_to_column("feature") %>%
                        pivot_longer(-feature, names_to = "sample", values_to = "predicted") %>%
                        full_join(as.data.frame(rowMeans(as.data.frame(as.matrix(logcounts_all[assayType %in% c("atac"), 5017:10032])))) %>%
                            rownames_to_column("feature")) %>%
                        rename(baseline = `rowMeans(as.data.frame(as.matrix(logcounts_all[assayType %in% c("atac"), 5017:10032])))`)

stab_mae <- mean(abs(stab_baseline_comp$predicted - stab_baseline_comp$baseline))


mofa_baseline_comp <- as.data.frame(trained_model@imputed_data$ATAC[[1]][,1:(ncol(logcounts_all)/2)]) %>%
                  rownames_to_column("feature") %>%
                  pivot_longer(-feature, names_to = "sample", values_to = "predicted") %>%
                        full_join(as.data.frame(rowMeans(as.data.frame(as.matrix(logcounts_allNA[953:1740, 5017:10032])))) %>%
                            rownames_to_column("feature")) %>%
                        rename(baseline = `rowMeans(as.data.frame(as.matrix(logcounts_allNA[953:1740, 5017:10032])))`)

mofa_mae <- mean(abs(mofa_baseline_comp$predicted - mofa_baseline_comp$baseline))
```

Plots for a random feature

```{r}
stab_baseline_comp %>%
  filter(feature == "chr1:994735-1006799") %>%
  left_join(all_celltypes %>% rownames_to_column("sample")) %>%
  mutate(diff = (predicted - baseline)) %>%
  mutate(sample = factor(sample, levels = sample[order(all_celltypes$celltype)])) %>%
    ggplot() +
  geom_col(aes(x = sample, y = diff, fill = celltype)) 



mofa_baseline_comp %>%
  filter(feature == "chr1:994735-1006799") %>%
  left_join(all_celltypes %>% rownames_to_column("sample")) %>%
  mutate(diff = (predicted - baseline)) %>%
  mutate(sample = factor(sample, levels = sample[order(all_celltypes$celltype)])) %>%
    ggplot() +
  geom_col(aes(x = sample, y = diff, fill = celltype)) 


# Comparing with the diff of the actual and predicted values
mofa_baseline_comp %>%
  filter(feature == "chr1:994735-1006799") %>%
  left_join(all_celltypes %>% rownames_to_column("sample")) %>%
  left_join(mofa_imp_comp %>% filter(feature == "chr1:994735-1006799")) %>%
  mutate(diff = (actual - predicted)) %>%
  mutate(sample = factor(sample, levels = sample[order(all_celltypes$celltype)])) %>%
    ggplot() +
  geom_col(aes(x = sample, y = diff, fill = celltype)) 

stab_baseline_comp %>%
  filter(feature == "chr1:994735-1006799") %>%
  left_join(all_celltypes %>% rownames_to_column("sample")) %>%
  left_join(stab_imp_comp %>% filter(feature == "chr1:994735-1006799")) %>%
  mutate(diff = (actual - predicted)) %>%
  mutate(sample = factor(sample, levels = sample[order(all_celltypes$celltype)])) %>%
    ggplot() +
  geom_col(aes(x = sample, y = diff, fill = celltype))

```
