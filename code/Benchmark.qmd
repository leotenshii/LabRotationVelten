---
title: "Benchmark"
author: "Leoni Zimmermann"
html:
  code-fold: true
  code-summary: "Show the code"
editor: visual
---

# Prep

## Libraries

```{r message=FALSE, warning=FALSE}
#---------------------------Seed------------------------------------------------
set.seed(42)
#---------------------------Libraries-------------------------------------------
library(MOFA2)
library(scater)
library(scran)
library(StabMap)
library(tidyverse)
library(cluster)
library(patchwork)
library(fpc)
library(MultiAssayExperiment)
library(plotly)

source("~/R/Functions/data_prep_functions.R")
source("~/R/Functions/integration_metrics_functions.R")
source("~/R/Functions/adaptiveKNN.R")
```

## Set values

```{r}
pathway_dataset <- "~/R/Data/data.RDS"

na_features <-  953:1740
na_cells <- 1:5016

```

## Preparing Data

Load Data

```{r}
#---------------------------Dataset---------------------------------------------
# Peripheral Blood Mononuclear Cells provided by 10x Genomics website
# 10x Genomics Multiome technology enables simultaneous profiling of the transcriptome 
# (using 3’ gene expression) and epigenome (using ATAC-seq) from single cells to deepen 
# our understanding of how genes are expressed and regulated across different cell types.

# mae <- scMultiome("pbmc_10x", mode = "*", dry.run = FALSE, format = "MTX")

# Loaded from RDS cause I cant install the SingleCellMultiModal package
mae <- readRDS(pathway_dataset)
metadata <- mae@colData
```

Normalization

```{r}
#---------------------------Data preparation------------------------------------
# RNA
sce.rna <- normalize_and_select_features(experiments(mae)[["rna"]], 0.01, 0.05)


# ATAC
sce.atac <- normalize_and_select_features(experiments(mae)[["atac"]], 0.25, 0.05)

# Combine
logcounts_all_matrix <- as.matrix(rbind(logcounts(sce.rna), logcounts(sce.atac)))

```

## Some general dataframes etc.

```{r}

# Celltypes of all samples
all_celltypes <- as.data.frame(setNames(metadata$celltype, colnames(logcounts_all_matrix))) %>%
                    rename(celltype = "setNames(metadata$celltype, colnames(logcounts_all_matrix))")

# Clusters
cluster <- as.data.frame(metadata) %>% 
  group_by(celltype) %>% 
  summarise(n = n()) %>% 
  mutate(n = 1:14) 
```

## StabMap

```{r}
#---------------------------StabMap---------------------------------------------

stab_list <- stab_build_model(data = logcounts_all_matrix, 
                              na_features =  na_features,
                              na_cells = na_cells)


# StabMap
mosaicDataUpSet(stab_list)
plot(mosaicDataTopology(stab_list))

stab = stabMap(stab_list,
               ncomponentsReference = 70,
               ncomponentsSubset = 70,
               reference_list = c("all_feat"),
               plot = FALSE,
               scale.center = FALSE,
               scale.scale = FALSE)

# UMAP
stab_umap_coord <- as.data.frame(calculateUMAP(t(stab)))


# Add metadata to the UMAP results (celltype, if it was an NA cell, cluster)
stab_umap <- merge( as.data.frame(metadata), stab_umap_coord, by =0 ) %>%
                mutate(isNA = if_else(Row.names %in% colnames(logcounts_all_matrix                                                        )[na_cells] , "NA", "notNA")) %>%  
                full_join(cluster) %>%
                column_to_rownames("Row.names")

```

## MOFA model

```{r}
#---------------------------MOFA------------------------------------------------

model <- mofa_build_model(data = logcounts_all_matrix, 
                          na_features =  na_features,
                          na_cells = na_cells,
                          groupname_with_na = "ATAC",
                          groupname_without_na = "RNA",
                          metadata = metadata)


plot_data_overview(model)


trained_model <- mofa_parameter_train(spikeslab_weights = FALSE, 
                                    model = model)

# UMAP
trained_model <- run_umap(trained_model)
mofa_umap_coord <- trained_model@dim_red$UMAP %>% select(UMAP1, UMAP2)

# Add metadata to the UMAP results (celltype, if it was an NA cell, cluster)
mofa_umap <- merge(trained_model@dim_red$UMAP, all_celltypes, by = 0)  %>%
                full_join(cluster) %>% 
                mutate(isNA = if_else(sample %in% colnames(logcounts_all_matrix                                                        )[na_cells] , "NA", "notNA")) %>%  
                column_to_rownames("Row.names") %>%
                select(-sample)
```

# Dimension reduction

## Comparison UMAPS

```{r}
# MOFA
UM1 <- plot_dimred(trained_model, method = "UMAP", color_by = "celltype", dot_size =1) + ggtitle("MOFA celltype")
UM2 <- plot_dimred(trained_model, method = "UMAP", color_by = "isNA", dot_size =1)+ ggtitle("MOFA NA")
UM3 <- plot_dimred(trained_model, method = "UMAP", color_by = "broad_celltype", dot_size =1)+ ggtitle("MOFA broad celltype")

# StabMap
US1 <- ggplot(stab_umap) +
  geom_point(aes(x = V1, y = V2, color = celltype), size = .1) +
  theme_light() +
  ggtitle("StabMap celltype")
US2 <- ggplot(stab_umap) +
  geom_point(aes(x = V1, y = V2, color = isNA), size = .1) +
  theme_light() +
  ggtitle("StabMap NA")
US3 <- ggplot(stab_umap) +
  geom_point(aes(x = V1, y = V2, color = broad_celltype), size = .1) +
  theme_light() +
  ggtitle("StabMap broad celltype")

# Plot
combined_plot <- (UM1 + UM2 + UM3) / (US1 + US2 + US3) + plot_annotation(title = 'Comparison UMAP')
print(combined_plot)

# Interactive plots
# ggplotly(UM1)
```

Nach Zelltyp: Mittelmäßig aufgetrennt

Nach groben Zelltyp: Gut aufgetrennt

Nach NA: Gut verteilt/nicht aufgetrennt (so sollte es sein)

Myeloid cells:

Classical Monocytes --\> intermediate MC --\> non-classical MC

Monocytes and dendritic cells (DC) have common ancestor

Lymphoid cells:

naive and memory B cells together (good)

plasmacytoid DC have common ancestor with myeloid dc, their progenitor can also make plasmacytoid dc

```         
"CD56 (bright) NK cells"  "CD56 (dim) NK cells"     "MAIT T cells"  "effector CD8 T cells"  "memory CD4 T cells"  "naive CD4 T cells" naive CD8 T cells
```

## Silhouette

```{r}
#StabMap celltype
stab_sil_sum <- silhouette_summary(stab_umap$n, stab_umap %>% select(V1, V2))

#StabMap NA
stab_sil_sum_NA <- silhouette_summary(
  stab_umap %>% mutate(isNA = ifelse(isNA == "NA", 1, 0)) %>% pull(isNA),
  stab_umap %>% select(V1, V2))

#MOFA celltype
mofa_sil_sum <- silhouette_summary(mofa_umap$n, mofa_umap %>% select(UMAP1, UMAP2))

#MOFA NA 
mofa_sil_sum_NA <- silhouette_summary(
  mofa_umap %>% mutate(isNA = ifelse(isNA == "NA", 1, 0)) %>% pull(isNA), 
  mofa_umap %>% select(UMAP1, UMAP2))
```

Zelltypen: Cluster 5 (effector CD8 T cells) für beide Methoden schlecht --\> -0.4243316 (MOFA). Überschneidet sich mit Kluster 3 (MAIT T cells), Kluster 8 (memory CD4 T cells) und 2 (CD56 (dim) NK cells)

Plasmocytoid DC cells für beide Methoden am besten

Mean score für StabMap: 0.39, MOFA: 0.45

## More cluster stats

```{r}
stab_cluster_stats <- cluster.stats(dist(stab_umap %>% select(V1, V2)), stab_umap$n)
mofa_cluster_stats <- cluster.stats(dist(mofa_umap %>% select(UMAP1, UMAP2)), mofa_umap$n)
```

## Celltype accuracy (from StabMap paper)

Given a joint embedding, we perform a simulation such that discrete class labels corresponding to cell types are artificially removed (atac_query are the "removed" ones) for a subset of the data. We then perform k-nearest neighbors classification (k=5) to obtain the predicted class label for the artificially unlabeled data. The cell type classification accuracy is thus the proportion of cells for which the classification is correct compared to the true cell type label

Find the k-nearest neighbors in one data set for each point in another query data set, using exact or approximate algorithms

uniformed_fixed =\> One fixed k for all

The balanced result is first mean for celltype, then mean over all celltypes. Unbalanced one is just the mean over all cells

```{r}
# Predict "ATAC only" cell's cell types 
# Split Data
rna_train <- stab_umap$celltype[na_cells]
names(rna_train) <- rownames(stab_umap)[na_cells]
atac_query <- stab_umap$celltype[setdiff(1:ncol(logcounts_all_matrix), na_cells)]
names(atac_query) <- rownames(stab_umap)[setdiff(1:ncol(logcounts_all_matrix), na_cells)]

# StabMap
stab_knn_out = embeddingKNN(stab_umap_coord,
                       rna_train,
                       type = "uniform_fixed",
                       k_values = 5)
stab_knn_acc = mean(isEqual(stab_knn_out[names(atac_query),"predicted_labels"], atac_query), na.rm = TRUE)
stab_knn_acc_bal = mean(unlist(lapply(split(isEqual(stab_knn_out[names(atac_query),"predicted_labels"], atac_query), atac_query), mean, na.rm = TRUE)))

# MOFA
mofa_knn_out = embeddingKNN(mofa_umap_coord,
                       rna_train,
                       type = "uniform_fixed",
                       k_values = 5)
mofa_knn_acc = mean(isEqual(mofa_knn_out[names(atac_query),"predicted_labels"], atac_query), na.rm = TRUE)
mofa_knn_acc_bal = mean(unlist(lapply(split(isEqual(mofa_knn_out[names(atac_query),"predicted_labels"], atac_query), atac_query), mean, na.rm = TRUE)))

# Result
cat(" Accuracy StabMap: ", stab_knn_acc,"/",stab_knn_acc_bal,"(per celltype)", "\n","Accuracy MOFA: ", mofa_knn_acc,"/",mofa_knn_acc_bal,"(per celltype)")

```

Interpretation result

## Ideas

from WNN paper: get predicted expression of a gene (They used CD25 since it is hard to distinguish T cells in the dim reduction) from averaging the neighbors expression. THen calculate Correlation (Pearson and SPearman) to get quality

```{r}
# CD25
# plot_dimred(trained_model, method = "UMAP", color_by = "IL2RA", dot_size =1)+ ggtitle("MOFA CD25")

# CD57
# plot_dimred(trained_model, method = "UMAP", color_by = "", dot_size =1)+ ggtitle("MOFA CD57")

```

# Imputation

```{r}
#---------------------------Imputation------------------------------------------
imp = imputeEmbedding(
  stab_list,
  stab,
  reference = colnames(stab_list[["all_feat"]]),
  query = colnames(stab_list[["missing_feat"]]))

trained_model <- impute(trained_model)

# imp$Multiome[953:963, 1:5]
# trained_model@imputed_data$ATAC[[1]][1:10, 1:5]

```

## RE

```{r}
stab_rmse <- rmse_imp(imp_data = imp$all_feat[na_features,], 
                      real_data = logcounts_all_matrix, 
                      na_features = na_features, 
                      na_cells = na_cells)

mofa_rmse<- rmse_imp(imp_data = trained_model@imputed_data$groupname_with_na[[1]][,na_cells],
                     real_data = logcounts_all_matrix, 
                     na_features = na_features, 
                      na_cells = na_cells)

cat(" StabMap RMSE:", stab_rmse, "\n", "MOFA RMSE:",mofa_rmse )
```

## Comparison against baseline

```{r}
# stab_baseline_comp <- as.data.frame(as.matrix(imp$Multiome)[953:1740,]) %>%
#                         rownames_to_column("feature") %>%
#                         pivot_longer(-feature, names_to = "sample", values_to = "predicted") %>%
#                         full_join(as.data.frame(rowMeans(as.data.frame(as.matrix(logcounts_all_matrix[assayType %in% c("atac"), 5017:10032])))) %>%
#                             rownames_to_column("feature")) %>%
#                         rename(baseline = `rowMeans(as.data.frame(as.matrix(logcounts_all_matrix[assayType %in% c("atac"), 5017:10032])))`)
# 
# stab_mae <- mean(abs(stab_baseline_comp$predicted - stab_baseline_comp$baseline))
# 
# 
# mofa_baseline_comp <- as.data.frame(trained_model@imputed_data$ATAC[[1]][,1:(ncol(logcounts_all_matrix)/2)]) %>%
#                   rownames_to_column("feature") %>%
#                   pivot_longer(-feature, names_to = "sample", values_to = "predicted") %>%
#                         full_join(as.data.frame(rowMeans(as.data.frame(as.matrix(logcounts_all_matrixNA[953:1740, 5017:10032])))) %>%
#                             rownames_to_column("feature")) %>%
#                         rename(baseline = `rowMeans(as.data.frame(as.matrix(logcounts_all_matrixNA[953:1740, 5017:10032])))`)
# 
# mofa_mae <- mean(abs(mofa_baseline_comp$predicted - mofa_baseline_comp$baseline))
```

Plots for a random feature

```{r}
# stab_baseline_comp %>%
#   filter(feature == "chr1:994735-1006799") %>%
#   left_join(all_celltypes %>% rownames_to_column("sample")) %>%
#   mutate(diff = (predicted - baseline)) %>%
#   mutate(sample = factor(sample, levels = sample[order(all_celltypes$celltype)])) %>%
#     ggplot() +
#   geom_col(aes(x = sample, y = diff, fill = celltype)) +
#   ggtitle("StabMap")
# 
# 
# 
# mofa_baseline_comp %>%
#   filter(feature == "chr1:994735-1006799") %>%
#   left_join(all_celltypes %>% rownames_to_column("sample")) %>%
#   mutate(diff = (predicted - baseline)) %>%
#   mutate(sample = factor(sample, levels = sample[order(all_celltypes$celltype)])) %>%
#     ggplot() +
#   geom_col(aes(x = sample, y = diff, fill = celltype)) +
#   ggtitle("MOFA")
# 
# 
# # Comparing with the diff of the actual and predicted values
# mofa_baseline_comp %>%
#   filter(feature == "chr1:994735-1006799") %>%
#   left_join(all_celltypes %>% rownames_to_column("sample")) %>%
#   left_join(mofa_imp_comp %>% filter(feature == "chr1:994735-1006799")) %>%
#   mutate(diff = (actual - predicted)) %>%
#   mutate(sample = factor(sample, levels = sample[order(all_celltypes$celltype)])) %>%
#     ggplot() +
#   geom_col(aes(x = sample, y = diff, fill = celltype)) 
# 
# stab_baseline_comp %>%
#   filter(feature == "chr1:994735-1006799") %>%
#   left_join(all_celltypes %>% rownames_to_column("sample")) %>%
#   left_join(stab_imp_comp %>% filter(feature == "chr1:994735-1006799")) %>%
#   mutate(diff = (actual - predicted)) %>%
#   mutate(sample = factor(sample, levels = sample[order(all_celltypes$celltype)])) %>%
#     ggplot() +
#   geom_col(aes(x = sample, y = diff, fill = celltype))

```
