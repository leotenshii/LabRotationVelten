---
title: "Benchmark"
author: "Leoni Zimmermann"
html:
  code-fold: true
  code-summary: "Show the code"
editor: visual
---

# Prep

## Libraries

```{r message=FALSE, warning=FALSE}
#---------------------------Seed------------------------------------------------
set.seed(42)
#---------------------------Libraries-------------------------------------------
library(MOFA2)
library(scater)
library(scran)
library(StabMap)
library(tidyverse)
library(cluster)
library(patchwork)
library(fpc)
library(MultiAssayExperiment)
library(plotly)
```

## Preparing Data

Load Data

```{r}
#---------------------------Dataset---------------------------------------------
# Peripheral Blood Mononuclear Cells provided by 10x Genomics website
# 10x Genomics Multiome technology enables simultaneous profiling of the transcriptome 
# (using 3’ gene expression) and epigenome (using ATAC-seq) from single cells to deepen 
# our understanding of how genes are expressed and regulated across different cell types.

# mae <- scMultiome("pbmc_10x", mode = "*", dry.run = FALSE, format = "MTX")

# Loaded from RDS cause I cant install the SingleCellMultiModal package
mae <- readRDS("~/R/Data/data.RDS")
metadata <- mae@colData
```

Normalization

```{r}
#---------------------------Data preperation------------------------------------
# Normalization RNA
sce.rna <- experiments(mae)[["rna"]]
sce.rna <- logNormCounts(sce.rna)

# Feature selection
decomp <- modelGeneVar(sce.rna)
hvgs <- rownames(decomp)[decomp$mean>0.01 & decomp$p.value <= 0.05]

sce.rna <- sce.rna[hvgs,]


# Normalization ATAC
sce.atac <- experiments(mae)[["atac"]]
sce.atac <- logNormCounts(sce.atac)

# Feature selection using highly variable peaks
decomp <- modelGeneVar(sce.atac)
hvgs <- rownames(decomp)[decomp$mean>0.25
                         & decomp$p.value <= 0.05]

sce.atac <- sce.atac[hvgs,]

logcounts_all <- rbind(logcounts(sce.rna), logcounts(sce.atac))
```

## Some general dataframes etc.

```{r}
# Celltypes of all samples
all_celltypes <- as.data.frame(setNames(metadata$celltype, colnames(logcounts_all))) %>%
                    rename(celltype = "setNames(metadata$celltype, colnames(logcounts_all))")

# Clusters
cluster <- as.data.frame(metadata) %>% group_by(celltype) %>% summarise(n = n()) %>% mutate(k = 1:14) %>% select(-n)
```


## StabMap

```{r}
#---------------------------StabMap---------------------------------------------

# Seperation ATAC Multiome
names <- c(rep("ATAC", ncol(logcounts_all)/2), rep("Multiome", ncol(logcounts_all)/2))

# Assay Types
assayType = ifelse(rownames(logcounts_all) %in% rownames(sce.rna),
                   "rna", "atac")

# List for StabMap
assay_list = list(
  ATAC = logcounts_all[assayType %in% c("atac"), names %in% c("ATAC")],
  Multiome = logcounts_all[assayType %in% c("rna", "atac"), names %in% c("Multiome")]
)

# StabMap
mosaicDataUpSet(assay_list)
plot(mosaicDataTopology(assay_list))

stab = stabMap(assay_list,
               reference_list = c("Multiome"),
               plot = FALSE)

# UMAP
stab_umap_coord <- as.data.frame(calculateUMAP(t(stab)))


# Add metadata to the UMAP results (celltype, if it was an NA cell, cluster)
stab_umap <- merge( as.data.frame(metadata), stab_umap_coord, by =0 ) %>% 
                mutate(isNA = ifelse(Row.names %in% colnames(assay_list$ATAC), 1, 0)) %>% # 1 is TRUE, 0 is FALSE
                full_join(cluster) %>%
                column_to_rownames("Row.names")

```

## MOFA model

```{r}
#---------------------------MOFA------------------------------------------------

# Put NAs in data, takes a long time
# logcounts_allNA <- logcounts_all
# logcounts_allNA[953:1740, 1:ncol(logcounts_all)/2] <- NA

logcounts_allNA <- readRDS("~/R/Data/logcountsNA.RDS")

# Create list for MOFA
mofa_list <- list(
  RNA =  logcounts_allNA[1:952,],
  ATAC = logcounts_allNA[953: 1740,]
)

# MOFA model and training
model <- create_mofa(mofa_list)
samples_metadata(model) <- as.data.frame(metadata) %>% 
                              rownames_to_column("sample") %>% 
                              mutate(isNA =  c(rep(1, ncol(logcounts_all)/2), rep(0, ncol(logcounts_all) - ncol(logcounts_all)/2))) # 1 is TRUE, 0 is FALSE
plot_data_overview(model)

model_opts <- get_default_model_options(model)
model_opts$num_factors <- 30
MOFAobject <- prepare_mofa(model,
                           model_options = model_opts)

 set.seed(42)
 run_mofa(MOFAobject, outfile = "R/Data/model.hdf5", use_basilisk = TRUE)

trained_model <- load_model("~/R/Data/model.hdf5")

# UMAP
trained_model <- run_umap(trained_model)
mofa_umap_coord <- trained_model@dim_red$UMAP %>% select(UMAP1, UMAP2)

# Add metadata to the UMAP results (celltype, if it was an NA cell, cluster)
mofa_umap <- merge(trained_model@dim_red$UMAP, all_celltypes, by = 0)  %>%
                full_join(cluster) %>% 
                mutate(isNA =  c(rep(1, ncol(logcounts_all)/2), rep(0, ncol(logcounts_all) - ncol(logcounts_all)/2))) %>%  # 1 is TRUE, 0 is FALSE
                column_to_rownames("Row.names") %>%
                select(-sample)
```

# Dimension reduction

## Comparison UMAPS

```{r}
# MOFA
UM1 <- plot_dimred(trained_model, method = "UMAP", color_by = "celltype", dot_size =1) + ggtitle("MOFA celltype")
UM2 <- plot_dimred(trained_model, method = "UMAP", color_by = "isNA", dot_size =1)+ ggtitle("MOFA NA")
UM3 <- plot_dimred(trained_model, method = "UMAP", color_by = "broad_celltype", dot_size =1)+ ggtitle("MOFA broad celltype")

# StabMap
US1 <- ggplot(stab_umap) +
  geom_point(aes(x = V1, y = V2, color = celltype), size = .1) +
  theme_light() +
  ggtitle("StabMap celltype")
US2 <- ggplot(stab_umap) +
  geom_point(aes(x = V1, y = V2, color = isNA), size = .1) +
  theme_light() +
  ggtitle("StabMap NA")
US3 <- ggplot(stab_umap) +
  geom_point(aes(x = V1, y = V2, color = broad_celltype), size = .1) +
  theme_light() +
  ggtitle("StabMap broad celltype")

# Plot
combined_plot <- (UM1 + UM2 + UM3) / (US1 + US2 + US3) + plot_annotation(title = 'Comparison UMAP')
print(combined_plot)

# Interactive plots
# ggplotly(UM1)
```
Nach Zelltyp: Mittelmäßig aufgetrennt
Nach groben Zelltyp: Gut aufgetrennt
Nach NA: Gut verteilt/nicht aufgetrennt (so sollte es sein)

## Silhouette

```{r}
#---------------------------Silhouette-------------------------------------------

#StabMap celltype

stab_sil <- silhouette(stab_umap$k, dist(stab_umap %>% select(V1, V2)))
stab_sil_sum <- stab_sil %>% 
  as.data.frame() %>% group_by(cluster) %>% summarise(score = mean(sil_width), 
                                                      frac_pos = sum(sil_width > 0)/n(),
                                                      pos_score = sum((sil_width>0)*sil_width)/sum(sil_width > 0)) #average quality of clustering for the well-clustered data points within each cluster
stab_sil_sum

#StabMap NA

stab_sil_NA <- silhouette(stab_umap$isNA, dist(stab_umap %>% select(V1, V2)))
stab_sil_sum_NA <- stab_sil_NA %>% 
  as.data.frame() %>% group_by(cluster) %>% summarise(score = mean(sil_width), 
                                                      frac_pos = sum(sil_width > 0)/n(),
                                                      pos_score = sum((sil_width>0)*sil_width)/sum(sil_width > 0))
stab_sil_sum_NA

#MOFA celltype

mofa_sil <- silhouette(mofa_umap$k, dist(mofa_umap %>% select(UMAP1, UMAP2)))
mofa_sil_sum <- mofa_sil %>% 
  as.data.frame() %>% group_by(cluster) %>% summarise(score = mean(sil_width), 
                                                      frac_pos = sum(sil_width > 0)/n(),
                                                      pos_score = sum((sil_width>0)*sil_width)/sum(sil_width > 0)) 
mofa_sil_sum

#MOFA NA 

mofa_sil_NA <- silhouette(mofa_umap$isNA, dist(mofa_umap %>% select(UMAP1, UMAP2)))
mofa_sil_sum_NA <- mofa_sil_NA %>% 
  as.data.frame() %>% group_by(cluster) %>% summarise(score = mean(sil_width), 
                                                      frac_pos = sum(sil_width > 0)/n(),
                                                      pos_score = sum((sil_width>0)*sil_width)/sum(sil_width > 0)) 
mofa_sil_sum_NA
```
Zelltypen: Cluster 5 (effector CD8 T cells) für beide Methoden schlecht --> -0.4243316 (MOFA). Überschneidet sich mit Kluster 3 (MAIT T cells), Kluster 8 (memory CD4 T cells) und 2 (CD56 (dim) NK cells)

Plasmocytoid DC cells für beide Methoden am besten

Mean score für StabMap: 0.39, MOFA: 0.45

## More cluster stats

```{r}
stab_cluster_stats <- cluster.stats(dist(stab_umap %>% select(V1, V2)), stab_umap$k)
mofa_cluster_stats <- cluster.stats(dist(mofa_umap %>% select(UMAP1, UMAP2)), mofa_umap$k)
```
May be interesting:
corrected.rand (Corrected Rand Index): Measures the similarity between the true labels and the clustering results. It accounts for chance groupings, making it a robust metric for comparing clustering performance against the ground truth.

entropy (Entropy of the Distribution of Cluster Memberships): Indicates how well the clusters are balanced. Lower entropy suggests more balanced cluster sizes, which is often desirable.

ch (Calinski and Harabasz Index): Assesses cluster dispersion and separation. Higher values indicate better clustering, balancing compactness and separation.

dunn (Dunn Index): Ratio of minimum inter-cluster distance to maximum intra-cluster distance. Higher values suggest well-separated and compact clusters.

pearsongamma (Pearson Gamma): Measures the correlation between distances and a binary vector indicating cluster membership. Higher values indicate a strong relationship between distance and cluster membership.

vi (Variation of Information Index): Quantifies the difference between the true labels and the clustering results. Lower values indicate better alignment with the ground truth.

## Celltype accuracy (from StabMap paper)

Given a joint embedding, we perform a simulation such that discrete class labels corresponding to cell types are artificially removed (atac_query are the "removed" ones) for a subset of the data. We then perform k-nearest neighbors classification (k=5) to obtain the predicted class label for the artificially unlabeled data. The cell type classification accuracy is thus the proportion of cells for which the classification is correct compared to the true cell type label

Find the k-nearest neighbors in one data set for each point in another query data set, using exact or
approximate algorithms

uniformed_fixed => One fixed k for all

The balanced eresult is first mean for celltype, then mean over all celltypes. Unbalanced one is just the mean over all cells

```{r}
source("adaptiveKNN.R")

# Predict "ATAC only" cell's cell types 
# Split Data
rna_train <- stab_umap$celltype[1:5016]
names(rna_train) <- rownames(stab_umap)[1:5016]
atac_query <- stab_umap$celltype[5016:10032]
names(atac_query) <- rownames(stab_umap)[5016:10032]

# StabMap
stab_knn_out = embeddingKNN(stab_umap_coord,
                       rna_train,
                       type = "uniform_fixed",
                       k_values = 5)
stab_knn_acc = mean(isEqual(stab_knn_out[names(atac_query),"predicted_labels"], atac_query), na.rm = TRUE)
stab_knn_acc_bal = mean(unlist(lapply(split(isEqual(stab_knn_out[names(atac_query),"predicted_labels"], atac_query), atac_query), mean, na.rm = TRUE)))

# MOFA
mofa_knn_out = embeddingKNN(mofa_umap_coord,
                       rna_train,
                       type = "uniform_fixed",
                       k_values = 5)
mofa_knn_acc = mean(isEqual(mofa_knn_out[names(atac_query),"predicted_labels"], atac_query), na.rm = TRUE)
mofa_knn_acc_bal = mean(unlist(lapply(split(isEqual(mofa_knn_out[names(atac_query),"predicted_labels"], atac_query), atac_query), mean, na.rm = TRUE)))

# Result
cat(" Accuracy StabMap: ", stab_knn_acc,"/",stab_knn_acc_bal,"(per celltype)", "\n","Accuracy MOFA: ", mofa_knn_acc,"/",mofa_knn_acc_bal,"(per celltype)")

```

Interpretation result

# Imputation

```{r}
#---------------------------Imputation------------------------------------------
imp = imputeEmbedding(
  assay_list,
  stab,
  reference = colnames(assay_list[["Multiome"]]),
  query = colnames(assay_list[["ATAC"]]))

trained_model <- impute(trained_model)
# imp$Multiome[953:963, 1:5]
# trained_model@imputed_data$ATAC[[1]][1:10, 1:5]

```

##RSME
```{r}
# StabMap
# Dataframe with predicted and real values

stab_imp_comp <- as.data.frame(as.matrix(imp$Multiome)[953:1740,]) %>%
                  rownames_to_column("feature") %>%
                  pivot_longer(-feature, names_to = "sample", values_to = "predicted") %>%
                  full_join(as.data.frame(as.matrix(logcounts_all[953:1740, 1:(ncol(logcounts_all)/2)])) %>%
                  rownames_to_column("feature") %>%
                  pivot_longer(-feature, names_to = "sample", values_to = "actual"))

stab_rsme <- sqrt(mean((stab_imp_comp$actual - stab_imp_comp$predicted)^2))

# MOFA
mofa_imp_comp <- as.data.frame(trained_model@imputed_data$ATAC[[1]][,1:(ncol(logcounts_all)/2)]) %>%
                  rownames_to_column("feature") %>%
                  pivot_longer(-feature, names_to = "sample", values_to = "predicted") %>%
                  full_join(as.data.frame(as.matrix(logcounts_all[953:1740, 1:(ncol(logcounts_all)/2)])) %>%
                  rownames_to_column("feature") %>%
                  pivot_longer(-feature, names_to = "sample", values_to = "actual"))

mofa_rsme <- sqrt(mean((mofa_imp_comp$actual - mofa_imp_comp$predicted)^2))

cat(" StabMap RSME:", stab_rsme, "\n", "MOFA RSME:",mofa_rsme )

```

